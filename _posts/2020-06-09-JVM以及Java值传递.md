---
layout: post
title: JVM以及Java值传递
tags: Java
---

> 先说一下Java的8种基本数据类型：**byte**---**short**---**int**---**long**---**float**---**double**---**boolean**---**char**
>
> 除了8种基本数据类型外，其它都是引用类型

> **Java工作原理**：
>
> 1.将`.java`文件编译成`.class`文件
>
> 2.将`.class`文件丢给JVM处理

> **JVM工作原理**：
>
> JVM在内存中开辟一片内存空间(也叫运行时数据区)
>
> 运行时数据区由以下几部分组成：
>
> **1**.**虚拟机栈**：栈是线程私有的，当程序开始执行一个方法时就会相应创建一个栈帧并入栈，方法结束后出栈，每个栈帧中包括：局部变量表，操作数栈，指向常量池的引用
>
> **2**.**堆**：JVM只有一个堆，纯村对象本身和数组，被线程所共享
>
> **3**.**方法区**：所有线程所共享，线程安全，多个线程访问方法区中同一个内容时，只能有一个线程装载数据，其它线程只能等待。储存一些：类的全路径名，常量池，类的类型等
>
> **4**.**程序计数器**：本地方法栈的功能和虚拟机栈是基本一致的，并且也是线程私有的，它们的区别在于虚拟机栈是为执行Java方法服务的，而本地方法栈是为执行本地方法服务的
>
> **5**.**本地方法栈**：本地方法栈的功能和虚拟机栈是基本一致的，并且也是线程私有的，它们的区别在于虚拟机栈是为执行Java方法服务的，而本地方法栈是为执行本地方法服务的。

> **基本数据类型局部变量(方法中的变量)**：直接储存在内存中的栈上，变量名字及值都储存在一起，栈中数据在当前线程下共享，当局部变量重新赋值时，是重新在栈中寻找新值，如果没有，则重新开辟内存存储新数据，并把局部变量的引用指向新数据所在地址

> **基本数据类型成员变量(在类体中定义的变量)**：在堆中开辟一块内存区域，用于放置这个引用对象，成员变量全部位于该对象所属内存区域中

> **基本数据类型的静态变量(static)**：方法区用来存储静态变量，因此基本数据类型的静态变量名以及值村春与方法区运行时常量池中，静态变量随类加载而加载，随类消失而消失

> **引用数据类型的存储**：
>
> ```java
> Person person = new Person();
> ```
>
> 变量person存储在栈中，且和指向new Person()这个新创建对象的内存地址也在栈中，而新创建的对象存储在堆中

> **基本数据类型的参数传递过程**：
>
> ```java
> public static void changeNum(int b){
>     System.out.println(b);
>     b = 10;
>     System.out.println(b);
> }
> 
> public static void main(String args[]){
>     int a = 12;
>     changeNum(a);
>     System.out.println(a);
> }
> 
> 
> >>12
> >>10
> >>12
> ```
>
> **过程解释**：一开始带着变量a的main()栈帧入栈，并赋值12，之后changeNum()该栈帧入栈，并将a的值copy副本给b,此时b在changeNum()栈中，之后在该栈帧中给b重新赋值10，之后方法结束，changeNum()栈弹出，main()栈中a值不变

> **引用数据类型的存储**：
>
> 同理上述，不过引用对象存储在堆中，因此：
>
> ```java
> Person per = new Person();
> Person per1;
> per1 = per;
> per.name = per1.name;
> per.name = 1;
> per1.name == 1; //true
> ```
>
> 栈中变量per所指向的是堆中对象的地址，因此copy的副本所指向的也是地址，即使不在一个栈帧中，其中一个改变，另外一个也会变。

> **补充：**
>
> 为什么会出现以下问题：
>
> ```java
> String a = new String("abc");
> String b = new String("abc");
> 
> a == b;//false
> ------------------------------------------------------------------------------
> String m = "a";
> String n = "a";
> 
> m == n;//true
> ```
>
> 出现第一中情况是因为a,b对应地址所指向的堆中对象不是一个，所以地址不同，false
>
> 出现第二种情况是因为在字符串常量池中写入“a”，字符串常量池中只能有一个"a"，因此指向的是同一个"a"，地址也相同，true





