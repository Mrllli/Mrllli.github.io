---
layout: post
title: select,poll,epoll
---

> 先来说一下前置知识，什么叫**用户空间**，什么叫**内核空间**，用户态，内核态。在机器启动的时候，是先将磁盘中的操作系统读取出来，然后在内存中分配一定的空间给操作系统，这就是**内核空间**。其余剩余的部分就是**用户空间**，在用户空间可以跑一些程序（进程）。内核可以调用所有的空间以及硬件设施，用户则有一定的权限，必须通过内核才能调用硬件，而且一些指令是禁止用户调用的。**用户态**调用**内核态**就是叫**系统调用**

> 什么叫**时钟中断**，时钟中断就是假设只有一个CPU，却有10个进程在跑，那这10个进程是并行的吗，并不是，是通过时钟中断来产生时间片，每个时间片跑某一个进程，由于速度快，因此看起来像是10个进程在一起运行。时钟中断就像是一个虚线，每个虚线的位置就是每一个时间片。每切换一次就把上一个的进程运行的信息保存在内存中，然后下次再调用的时候再取出来，再接着运行。

> 什么叫**软中断**，软中断就是假设用户态要调用一个硬件，则发送一个**80中断**给内核态，先进行系统调用，然后内核态把信息传递给CPU，CPU进行中断，把进程信息保存在内存中，然后返回给内核态信息，内核态调用相应的硬件，然后把结果信息返回给用户态，同时告诉CPU已经返回信息了，CPU再从中断中恢复，从内存中取出之前保存的信息继续运行，CPU可以直接访问内存，用户态访问硬件需要经过内核态。

> 接下来就是IO的知识，同步方法有三种，**BIO**,**NIO**,**IO**多路复用，异步的方法只有一种，且只有在windows中才存在。怎么划分同步和一步呢，需要用户自己去读的recv就是同步，不需要自己去读对的就是异步，BIO就是阻塞IO，NIO就是非阻塞IO，NIO是不断的去轮询所有的fds，轮询每个fds的时候都有一次系统调用，因此会大量浪费时间和资源。IO多路复用就是运用select,将所有的fds全部拷贝到内核空间，由内核态去轮询所有的fds，因此不需要系统调用，效率极大提升，当轮询到有信息传过的时候，则通知用户态，用户自己调用recv去读，因此若是有100个fds过来，只有3个fds发信息，程序只需要调用3+1次系统调用，极大提升效率。**select**有限制只能接受1024个fds的，poll就没有数量限制，它是根据你机器配置来自动生成最大限制数的。**select**和**poll**是同一类的多路复用器，epoll是另外一种多路复用器。select和poll的缺点就是在整个while(true)的过程中，每循环一次都需要把所有的fds拷贝到内存空间，且内存空间每次读取是刷新重读，而不是从上一次读到的地方继续读。现在用的比较多的还是epoll，epoll底层是先调用epoll_create在内核空间开辟一片区域存储用来存储fd，这个只需要调用一次，然后会返回该片区域的fd，然后调用epoll_ctl这个方法是将新进来的fd存储入刚刚开辟的那片内存区域，然后另一个CPU会将有io事件的fd传入另一个区域，然后可以调用epoll_wait将有io状态的fd读取出来，通知用户态，用户态再调用recv去读，可以实现CPU并行，提高效率。epoll_create开辟的内存空间存储结构为红黑树。