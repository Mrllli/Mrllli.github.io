---
layout: post
title: hashMap
tags: 数据结构
---

> 散列表又叫做哈希表，散列表本质上是一个数组
>
> 以Java中得HashMap为例，每一个对象都有属于自己得hashcode，无论对象自身类型是什么，hashcode都是一个整型变量

> 例如：
>
> ```java
> hashMap("002931","王五");
> ```
>
> 第一步：通过哈希函数把key转换为数组下标5
>
> 第二步：如果数组下标5位置没有对应元素，就把**Entry(键值对)**填充到数组下标5的位置

> **哈希冲突**
>
> 解决方法：**开放寻址法**，**链表法**
>
> **开放寻址法：**假如Entry对应数组下标2，而2已经有元素，则向后移动一位，看3有没有，没有就填充，有就继续下一位，寻址方法有多种，不一定是寻找后一个元素，这只是一个简单示例。
>
> **链表法：**HashMap数组的每一个元素不仅是一个Entry对象，还是一个链表的头节 点。每一个Entry对象通过next指针指向它的下一个Entry节点。当新来的 Entry映射到与之冲突的数组位置时，只需要插入到对应的链表中即 可。

> **读操作**
>
> 例如：
>
> ```java
> hashMap.get("002067")
> ```
>
> 第一步：通过哈希函数把key值转化成数组下标2
>
> 第二步：找到数组下标2的位置，如果这个元素的key是002067，那么就找到；如果不是，可以顺着链表慢慢往下找，看能否找到与key相匹配的节点

> **扩容**
>
> 为什么要扩容：当经过多次元素插入，散列表达到一定饱和度时，Key映射位置发生冲 突的概率会逐渐提高。这样一来，大量元素拥挤在相同的数组下标位 置，形成很长的链表，对后续插入操作和查询操作的性能都有很大影响。
>
> **扩容方法：**1.创建一个新的Entry数组，长度是原来数组的两倍。2.重新Hash，遍历原来Entry数组，将所有Entry重新Hash到新数组中，因为长度改变Hash规则改变。经过扩容，散列表变得稀疏。

> **补充**：当多个Entry被Hash到同一个数组下标时，HashMap会把Entry的链表转换为红黑树这种数据结构。