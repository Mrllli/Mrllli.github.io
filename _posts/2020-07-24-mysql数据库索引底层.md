---
layout: post
title: mysql数据库索引底层
---

> 众所周知，mysql索引底层的数据结构是B+树，那为什么是B+树呢，先从二叉树说起

> 二叉树就是根节点有左右节点的一种数据结构，BST树就是一种二叉树的升级版，它的规则就是左节点小于根节点，根节点小于右节点，它的查询复杂度是logn，但是这也会产生一种问题，就是可能插入数据是递增或是递减的，就会造成它不平衡，时间复杂度变大。因此又演变出了一种新的树，叫AVL树，它这种树会自适应，就是会左旋或者右旋调整使最长路径减去最短路径不大于1.但是这也会造成一种问题，就是会造成插入效率降低。因此为了平衡插入效率和查询效率又引入了一种新的树，叫红黑树，它的规则是最大路径长度最多为最短路径的两倍。这样就平衡了插入效率和查询效率。但是这些树的结构都不适用于数据库查询。因为操作系统与硬盘交互取出数据是通过取出一块的数据，而不是一个一个取，这样可以降低与磁盘IO的次数，提高效率，一块数据也叫页。因此诞生了一个新的树结构，B树，但是B树也有它的缺点，虽然它的数据存储是一块一块的，但是每一块都装了数据，查询三层的B树，只能获得4096个数据，如果数据量过大，又会增加IO的次数，因此出现了B+树，B+树只在叶子节点存放数据，其它数据块都存的是指针，指针的大小可比数据小很多，因此一个三层的B+数能存储的数据是B树的几个数量级的倍数。

> 再来说说什么叫回表查询，回表查询就是，一个name索引是一个B+树，但是它的叶子节点里装的是主键id的值，因此想查询
>
> ```mysql
> select * from tb where name = li;//id主键，name普通索引
> //索引的种类有，主键索引，唯一索引，普通索引，组合索引，全文索引
> ```
>
> 就需要先查name这个B+树，再去查id这个B+树，然后在B+树的叶子节点里才有所需要的数据，数据行是存储在一个B+树里的，不是每个B+树，因此IO了6次

> 什么叫索引覆盖，就是查询
>
> ```mysql
> select id,name from tb where name = li;
> ```
>
> 单单从name这个B+树里就可以查询到所需要结果，就不需要回表，这就是索引覆盖

> 什么叫最左匹配，就是组合索引是有一定顺序的，不能跨列，必须一个接着一个的使用
>
> ```mysql
> select * from tb where id=1 and name = li;//(id,name)
> select * from tb where name = 1;//索引失效
> ```

