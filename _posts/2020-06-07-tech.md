---
layout: post
title: TCP/IP
tags: TCP/IP
---

> TCP/IP 协议栈一共分为 4 个层次。从低到高依次排序是：数据链路层、网络层、传输层、应用层。

> TCP协议是实现端口到端口通信，且计算机传输数据的本质是byte流，因此TCP是采用流通信。

> 传输层下一层为网络层，因此TCP下一层是IP层，因此TCP采用IP规定的方式传输数据，IP协议是通过数据包传输数据，因此需要将TCP层数据流分割成一个个数据片段，丢给网络层打包进行数据传输。但是由于IP协议传输数据时不会按照顺序进行传输，因此TCP会在每个数据片段加上头部，每个头部带有序号，方便后续排序。



> 由于IP协议不太靠谱，数据包可能发送不成功，数据包可能丢失，接收端可能接收不到数据包，基于以上三个可能出错的原因，TCP提出两个补救措施。

> 1.在每收到一个数据片段后向发送方发送一个特殊的TCP片段，名叫ACK回复，如果接收到片段的序号为X，则ACK回复X+1，也就是接收方期待接受的下一个发送片段的序号

> 2.重新发送机制：在等待一段时间没收到ACK回复后，会重新发送异常片段，继续等待ACK回复，如果>没有，则再重新发送一场片段，继续等待...



> 但是这样做会造成效率低下，因此实际应用中采用窗口**滑动机制**
>
> 当发送方窗口大小为三，且发送序号为1,2,3，但是服务方返回的是3，则说明只能接受到2个数据，因此下回发数据为3,4，服务器返回5，则说明一切正常，发送方窗口大小变为2。这样做的好处是可以动态调整窗口大小，也可以不必发一个回复一个ACK，增加效率



> **TCP三次握手以及四次挥手**

> **第一次握手(SYN=1, seq=x)**
>
> 客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里，进入 `SYN_SEND`状态

> **第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1)**
>
> 服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 `SYN_RCVD` 状态

> **第三次握手(ACK=1，ACKnum=y+1)**
>
> 客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1
>
> 发送完毕后，客户端进入 `ESTABLISHED` 状态，当服务器端接收到这个包时，也进入 `ESTABLISHED` 状态，TCP 握手结束。



> **TCP四次挥手**

> **第一次挥手(FIN=1，seq=x)**
>
> 客户端想要关闭连接，发送FIN为1的数据包表示无数据发送，进入`FIN_WAIT_1`状态

>**第二次挥手(ACK=1,ACKnum=x+1)**
>
>服务器确认客户端FIN包，表示收到请求，但还没准备好关闭连接，服务器进入`CLOSE_WAIT` 状态，客户端进入`FIN_WAIT_2`状态

>**第三次挥手(FIN=1,seq=y)**
>
>服务器准备好关闭连接，向客户端发出请求，FIN为1
>
>服务器进入`LAST_ACK`状态，等待客户端的ACK

>**第四次挥手(ACK=1,ACKnum=y+1)**
>
>客户端收到服务端关闭请求，发送确认包，进入`TIME_WAIT`状态
>
>服务器端收到包，关闭连接进入`CLOSED`状态
>
>客户端等待一段时间后，没有收到服务器的ACK，证明已经正常关闭连接自己也进入`CLOSED`状态





