---
layout: post
title: redis
tags: redis
---

> redis有五种基本的数据类型，分别是字符串，list列表，hash字典，set无序集合和zset有序集合
>
> List相当于Java里的LinkedList,写操作很快O(1),读操作很慢O(n)，底层是quickList，这个是将链表和ziplist组合起来，ziplist使用的是一块连续的内存空间，减少单个链表节点额外指针prev和next造成的空间浪费
>
> Hash相当于Java里的HashMap,Key值为字典名
>
> Set相当于Java里的HashSet，Key值为集合名
>
> Zset是HashMap和SortedSet的结合体，底层是跳跃列表和哈希表，HashMap保证唯一性，跳跃列表保证排序(value,score) 

> **分布式锁**
>
> 分布式锁用于解决多个客户端同时操纵一个set的问题，一个客户端加锁后，其它客户端无法访问                                             
>
> ```redis
> >setnx lock:books true//加锁
> ok
> >expire lock:books 5//设置锁的过期时间，防止代码执行异常后，造成死锁
> ...do...
> >del lock:codehole//代码正常执行完后删除锁
> ```
>
> 这样做也有问题，如果在设置锁和设置过期时间中间挂掉也会造成死锁，因为这两个加在一起不是原子操作，优化如下                             
>
> ```redis
> >set lock:books true ex 5 nx
> ok
> ...do...
> >del lock:books
> ```
>
> 这样就把上述两步变成一步完成的原子操作

> **QPS和TPS**     
>
> **QPS:**每秒**响应**的请求数
>
> **TPS:**服务器每秒处理的事务数，TPS包含一条消息入和一条消息出，加上用户数据库的访问

> **延时队列**
>
> 通过redis的zset来实现，把消息序列化成一个字符串作为zset的value，设置这个消息的到期处理时间为score，然后用多个线程轮询zset获取到期任务进行处理

> **位图**
>
> 位图就是普通字符串，也就是byte数组，不过它是通过bit来存储，也就是位数组来存储，可以用来存储签到这种数据，只有0和1之分的数据

> **HyperLogLog**
>
>  一种高级数据结构，与sadd用法一样，可以用来统计每天访问页面的用户数(不可重复)，如果用set的话就很浪费空间，大约占12KB

> **布隆过滤器**
>
> 也是一个set结构，当布隆过滤器说一个值存在时，这个值可能不存在。当布隆过滤器说一个值不存在时，这个值一定不存在

> **简单限流**，**漏斗限流**    

>  **GeoHash**           
>
> 用数据库算附近的人，二维坐标映射到一维上，使用二刀切算法，一维坐标上相近的实际地理位置也相近

> Scan
>
> ```redis
> scan 0 match key* count 1000
> ```
>
> 一次遍历的槽位数，redis里所有key都是存在于一个很大的字典中，0代表cursor,代表开始遍历的槽位数，key*是正则表达式，表示要找的key是啥样的，1000表示一次遍历的槽有1000个。由于每个槽下所接的链表数不同，因此每一次遍历的实际key数量也不同。它会一次性把遍历1000个槽及其所挂链表所找到符合条件一次性返回

> **HashMap扩容机制**
>
> redis里的扩容机制简单来说就是原来8位的槽位xxx扩容后将原来的xxx下所挂的链表平均分配到0xxx和1xxx中去，16位扩到32位就是xxxx扩到0xxxx和1xxxx中去

​                                                                       