---
layout: post
title: redis
tags: redis
---

> redis有五种基本的数据类型，分别是字符串，list列表，hash字典，set无序集合和zset有序集合
>
> List相当于Java里的LinkedList,写操作很快O(1),读操作很慢O(n)，底层是quickList，这个是将链表和ziplist组合起来，ziplist使用的是一块连续的内存空间，减少单个链表节点额外指针prev和next造成的空间浪费
>
> Hash相当于Java里的HashMap,Key值为字典名
>
> Set相当于Java里的HashSet，Key值为集合名
>
> Zset是HashMap和SortedSet的结合体，底层是跳跃列表和哈希表，HashMap保证唯一性，跳跃列表保证排序(value,score) 

> **分布式锁**
>
> 分布式锁用于解决多个客户端同时操纵一个set的问题，一个客户端加锁后，其它客户端无法访问                                             
>
> ```redis
> >setnx lock:books true//加锁
> ok
> >expire lock:books 5//设置锁的过期时间，防止代码执行异常后，造成死锁
> ...do...
> >del lock:codehole//代码正常执行完后删除锁
> ```
>
> 这样做也有问题，如果在设置锁和设置过期时间中间挂掉也会造成死锁，因为这两个加在一起不是原子操作，优化如下                             
>
> ```redis
> >set lock:books true ex 5 nx
> ok
> ...do...
> >del lock:books
> ```
>
> 这样就把上述两步变成一步完成的原子操作

> **QPS和TPS**     
>
> **QPS:**每秒**响应**的请求数
>
> **TPS:**服务器每秒处理的事务数，TPS包含一条消息入和一条消息出，加上用户数据库的访问

> **延时队列**
>
> 通过redis的zset来实现，把消息序列化成一个字符串作为zset的value，设置这个消息的到期处理时间为score，然后用多个线程轮询zset获取到期任务进行处理

> **位图**
>
> 位图就是普通字符串，也就是byte数组，不过它是通过bit来存储，也就是位数组来存储，可以用来存储签到这种数据，只有0和1之分的数据

> **HyperLogLog**
>
>  一种高级数据结构，与sadd用法一样，可以用来统计每天访问页面的用户数(不可重复)，如果用set的话就很浪费空间，大约占12KB

> **布隆过滤器**
>
> 也是一个set结构，当布隆过滤器说一个值存在时，这个值可能不存在。当布隆过滤器说一个值不存在时，这个值一定不存在

> **简单限流**，**漏斗限流**    

>  **GeoHash**           
>
> 用数据库算附近的人，二维坐标映射到一维上，使用二刀切算法，一维坐标上相近的实际地理位置也相近

> Scan
>
> ```redis
> scan 0 match key* count 1000
> ```
>
> 一次遍历的槽位数，redis里所有key都是存在于一个很大的字典中，0代表cursor,代表开始遍历的槽位数，key*是正则表达式，表示要找的key是啥样的，1000表示一次遍历的槽有1000个。由于每个槽下所接的链表数不同，因此每一次遍历的实际key数量也不同。它会一次性把遍历1000个槽及其所挂链表所找到符合条件一次性返回

> **HashMap扩容机制**
>
> redis里的扩容机制简单来说就是原来8位的槽位xxx扩容后将原来的xxx下所挂的链表平均分配到0xxx和1xxx中去，16位扩到32位就是xxxx扩到0xxxx和1xxxx中去

> **AOF和快照**
>
> **AOF**和**快照**的持久化机制的一种
>
> **快照**使用操作系统的多进程机制COW，fork出一个子进程，fork的瞬间子进程和父进程共用一个内存的数据结构，此时子进程开始对磁盘读写，写入内存上快照下来的数据结构，父进程则继续接受客户端请求，由于内存分成很多页面存储数据段，因此只需要将需要修改的数据段复制一份下来进行修改就好
>
> **AOF**日志存储了Redis实例创建以来所有的指令和修改序列，因此AOF非常大量，因此需要对其进行瘦身，瘦身时Redis会根据内存进行遍历，转换一系列新的Redis指令变成AOF日志，在此期间发生的修改操作则等该过程结束后添加到AOF日志末尾即可
>
> **混合持久化**是将快照持久化到磁盘期间的操作指令记录到AOF日志文件中去，在Redis重启时，先加载rdb内容，后重放AOF日志，效率大大提升

> **管道**
>
> 管道是多条指令一起发送，多条指令一起接收，管道本质是，客户端调用操作系统内核为socket分配的sendbuffer中，然后sendbuffer发送给网卡，网卡通过网际路由发送给服务器网卡，服务器网卡发送给服务器的recbuffer，服务器进程调用read从缓冲中读取消息，因此write几乎没有开销，真正的开销是网际间传输的开销。因此诞生了管道
>
> **事务**
>
> Redis里事务基本所用的发送方式的都是管道

> **多线程Redis**指的是IO多线程，Redis执行计算操作的时候依然是单线程

​                                                                       