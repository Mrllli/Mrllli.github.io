---
layout: post
title: JVM垃圾回收
tags: java
---

> JVM垃圾回收算法主要是针对于JVM内存模型里的Java堆进行回收，下面谈谈我个人对JVM垃圾回收的理解

> JVM垃圾回收分为两步，第一步你要判断该对象能不能回收，第二步你要针对不同的回收制定相应的算法
>
> 判断该对象能不能回收的主流算法就是：可达性分析算法，这个算法就是从GC ROOT开始向下搜索，搜索路径就是引用链，如果一个对象没有任何引用链连着，那么这个对象就是可回收的
>
> 回收算法包括几个，先说说分代收集算法，这个算法就是把JAVA堆分成几个不同的区域，新生代区域，老年代区域，永久代区域。其中新生代区域放置的是刚刚新生成的对象。老年代放置的的是生命周期较长的对象，比如一个在新生代n次回收后都存活的对象就会被放到老年代区域。永久代区域放置的是静态文件，如JAVA类等。新生代垃圾回收使用的是复制算法，这个算法就是将新生代内存分成相等两块，其中一块满了之后，触发算法，将这块上所有存活的对象复制到另一块上，这一块清空，这样循环往复。老年代垃圾回收的算法是标记整理算法，这个算法是清除所有死亡对象，并将存活的对象移向同一端，因此不会产生内存碎片。老年代满了会触发FullGC，新生代老年代都进行回收。新生代会触发MinorGC，发生频率较高，不一定等Eden满了才触发

> 强引用：类似Object o = new Object();只要这个存在，垃圾收集器永远不会回收对象
>
> 软引用：在系统发生内存溢出的异常之前，会把这些对象回收
>
> 弱引用：只能生存到下一次垃圾回收之前，无论内存是否够用都会回收
>
> 虚引用：最弱的，目的就是希望能在这个对象被收集器回收时收到一个系统通知

> 内存泄漏，如下
>
> ```java
> public static Vectory vec = new Vectory();
> 
> public void add(){
> 	for(int i=0;i<1000;i++){
>         Object o = new Object();
>         vec.add(o);
>         o = null;
>     }
> }
> 
> ```
>
> 引用o指向null，但是对象仍然被引用，且无法被清除，因为静态变量生命周期和程序一样长，储存在方法区