---
layout: post
title: MySQL隔离级别和视图
---

> 数据库隔离级别有读未提交，读已提交，可重复读和串行化四个，对应的情况不同。举例说明
>
> | 事务A开始执行 |                 |
> | ------------- | --------------- |
> | 查询K的值为1  |                 |
> |               | 事务B开始执行   |
> |               | 修改K的值为2    |
> | 查询K的值K1   |                 |
> |               | 提交，结束事务B |
> | 查询K的值K2   |                 |
> | 结束事务A     |                 |
> | 查询K的值K3   |                 |
>
> 在读未提交隔离级别下，K1,K2,K3都为2
>
> 在读已提交隔离级别下，K1为1，K2和K3为2
>
> 在可重复读隔离级别下，K1，K2为1，K3为2
>
> 在串行化隔离级别下，当事务B执行修改操作的时候会被锁住，等到事务A执行完才能继续执行事务B，因此K1,K2为1，K3为2

> 上述的隔离级别是如何实现的呢，其实就是通过视图实现的，读未提交隔离级别下，不会有视图存在，因此查询到的值为最新的值。读已提交的隔离级别下，每次执行SQL语句会生成一个新的视图。在可重复读隔离级别下，每次开启事务的时候会生成一个视图，同一个事务里所使用相同的视图，全量视图

> 由于Oracle默认为读已提交，因此从Oracle迁移到Mysql需要将隔离级别设置为读已提交

> MVCC并发版本控制，针对可重复读隔离级别下的MVCC，每一个事物开启之后都会生成一个视图，Mysql里修改一个记录的值会记录前一个值，因此可以采用回滚操作回滚到前一个值，因此这里就会记录一个回滚日志，可以通过回滚日志回滚修改过后的值，那回滚日志不可能无限大，因此什么时候删除回滚日志呢，当最老的事务提交后，就会相应的删除该事务视图对应回滚日志当中的值，因此需要尽量避免使用长事务，造成大量回滚日志的产生

> ```mysql
> set autocommit = 0;
> //关闭事务的自动提交
> ```